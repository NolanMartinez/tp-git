Partie 1

Ouvrir un terminal (terminal Git Bash à privilégier)

Créer, en ligne de commande, un répertoire tp-git
Mkdir tp-git

Se déplacer dans le répertoire
cd tp-git

Vérifier qu'on est dans le bon répertoire en affichant le chemin du répertoire courant
pwd

Initialiser un dépôt Git

git init

Lister tous les fichiers du répertoire (y compris les fichiers cachés) pour s'assurer que le répertoire .git à été créé

ls -a

Ouvrir ce répertoire sous VS Code

Exécuter git status et copier/coller la sortie

On branch master

No commits yet

nothing to commit (create/copy files and use "git add" to track)

Créer le fichier fichier1.md avec un contenu quelconque et l'enregistrer (vous pouvez utiliser VS Code pour créer et éditer des fichiers)

Attention, il s'agit bien de créer un nouveau fichier, et non un répertoire. Il en sera de même tout au long de ce TP.
Créer le fichier fichier2.md avec un contenu quelconque et l'enregistrer

Exécuter git status et copier/coller la sortie

On branch master

No commits yet

Untracked files:
  (use "git add <file>..." to include in what will be committed)
        fichier1.md.txt
        fichier2.md.txt

nothing added to commit but untracked files present (use "git add" to track)

Ajouter fichier1.md à l'index de Git (zone de Staging)

git add fichier1.md

Exécuter git status et copier/coller la sortie

On branch master

No commits yet

Changes to be committed:
  (use "git rm --cached <file>..." to unstage)
        new file:   fichier1.md.txt

Untracked files:
  (use "git add <file>..." to include in what will be committed)
        fichier2.md.txt


Créer un commit avec pour message : "Ajout de fichier1.md"

$ git commit -m "ajout de fichier1.md"
[master (root-commit) 6288541] ajout de fichier1.md
 1 file changed, 0 insertions(+), 0 deletions(-)
 create mode 100644 fichier1.md.txt


VALIDATION PROF01

Exécuter git status et copier/coller la sortie

$ git status
On branch master
Untracked files:
  (use "git add <file>..." to include in what will be committed)
        fichier2.md.txt

nothing added to commit but untracked files present (use "git add" to track)


Modifier fichier1.md et enregistrer

Exécuter git status et copier/coller la sortie

$ git status
On branch master
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
        modified:   fichier1.md.txt

Untracked files:
  (use "git add <file>..." to include in what will be committed)
        fichier2.md.txt

no changes added to commit (use "git add" and/or "git commit -a")


Ajouter fichier1.md et fichier2.md à la zone de Staging

git add fichier1.md

git add fichier2.md

Créer un commit "Ajout de fichier2.md et modification de fichier1.md"

git commit -m "ajout de fichier2.md et modification de fichier1.md"


Exécuter git status et copier/coller la sortie

$ git status
On branch master
nothing to commit, working tree clean


Copier/coller l'ID des deux premiers commits (utiliser log) :

ID commit 1 : commit ca8a795de0681588e3b2a390185c9737808bd655
ID commit 2 : commit 62885412d6cfceb1fc76445c30271184c1feea42

Que signifie qu'un fichier est "tracked" ou "untracked" ?

un fichier tracked est un fichier qui a étais ajouté à l'index et un fichier untracked non

Pourquoi doit-on passer les fichiers par la zone de Staging (l'index) avant de les committer ?

Elle permet de choisir les modifications qui feront parti du commit et pouvoir avoir un "historique du fichier"

Partie 2

Créer une branche fonctionnalite1

git branch fonctionnalite1


Lister les branches

$ git branch
  fonctionnalite1
* master


Se déplacer sur la branche fonctionnalite1

git checkout fonctionnalite1

Lister les branches

$ git branch
* fonctionnalite1
  master


Que représente l'étoile à côté des noms des branches ?

C'est la branche sur laquelle on est située

Créer un nouveau fichier fichier3.md

Modifier le fichier fichier2.md

Comment utiliser VS Code pour qu'il nous montre les différences entre l'ancienne version de fichier2.md et la version courante que l'on vient d'éditer ?

On va sur la partie source control dans les icones en haut a gauche et on peux voir les différent stage de modification

Committer ces deux modifications : "Fonctionnalité 1 - première phase"

$ git commit -m "Fonctionnalité1 - première phase"


Créer un nouveau fichier fichier4.md

Modifier de nouveau le fichier fichier2.md

Committer ces deux modifications : "Fonctionnalité 1 - terminée"

git commit -m "Fonctionnalité 1 - terminée"


VALIDATION PROF03

Afficher la liste des fichiers du répertoire

ls
fichier1.md.txt  fichier2.md.txt  fichier3.md.txt  fichier4.md.txt


Se déplacer sur la branche master

git checkout master

Afficher la liste des fichiers du répertoire

$ ls
fichier1.md.txt  fichier2.md.txt 

Pourquoi les deux sorties sont-elles différentes ? Les fichiers ont-ils disparus ?

Les fichiers 3 et 4 n'en font pas parti car ils font parties de la branche fonctionnalité1 et nous sommes dans la branche master

Créer une nouvelle branche fonctionnalite2

git branch fonctionnalite2

Cette branche ne va pas avoir toutes les données incluses dans fonctionnalite1. Pourquoi ?

Car c'est une nouvelle branche et qu'elle ne fais pas partie de fonctionnalite1

Qu'aurait-il fallu faire si on avait souhaité démarrer la branche fonctionnalite2 en intégrant les modifications récentes de fonctionnalite1 ?

Créer la branche fonctionnalite2 pour faire en sorte qu'elle pointe vers la branche fonctionnalite1

Se déplacer sur la nouvelle branche fonctionnalite2

git checkout fonctionnalite2

Créer un nouveau fichier fichier5.md

touch fichier5.md

Faire un commit intégrant cette ajout : "Ajout fichier5.md"

git commit -m "Ajout fichier5.md"

Entrer la commande git log --oneline --decorate --graph --all pour visualiser, sur le terminal, le graphe des commits sur toutes les branches

Noter la « déviation » entre les deux branches, à partir de la branche master (schématisée sous forme de traits)

La branche fonctionnalite 1 se sépare de la branche master ainsi que la branche fonctionnalité 2 tout étant chacune lié toujours à la branche master

l'option --all permet de visualiser toutes les branches, pas seulement celle sur laquelle on est
l'option --oneline affiche les commits sur une seule ligne
l'option --graph affiche le log sous forme de graphe
(utilisez si besoin les touches haut/bas pour naviguer dans la sortie de cette commande et Q pour quitter)
Installer l'extension VS Code Git Graph et visualiser le graphe actuel des commits à l'aide de cette extension

Sur cette représentation, que représente les points ?

Les points représente tout les commit réaliser

Comment voit-on sur quelle branche on est actuellement ?

la branche ou il y'a un cercle sans fond

Partie 3

se déplacer sur la branche master

git checkout master

Noter le changement dans l'onglet Git Graph

Il nous indique que nous nous situons sur la branche master

On va maintenant intégrer la branche fonctionnalite1, qui est terminée, dans la branche d'intégration (ça s'appelle une fusion, ou un merge) : fusionner avec la branche fonctionnalite1

git merge fonctionnalite1

Noter le changement dans l'onglet Git Graph. Que signifie la mention Fast-forward indiquée par la sortie de la commande ?

La branche fonctionnalite1 a désormer fusionnée avec la branche master. 
Fast - forward veux dire que git déplace seulement la pointe de la branche actuelle vers celle ciblée

On veut maintenant fusionner fonctionnalite2 dans la branche d'intégration (master). Effectuer cette fusion

git merge fonctionnalite2

Noter le changement dans l'onglet Git Graph. Que signifie la mention Merge made by the ... strategy indiquée par la sortie de la commande ?

La branche master se situe dorénavant tout en haut de l'arbre 

made by the ort strategy est la stratégie par défaut sur git pour fusionner deux branches

Quelle est la différence fondamentale avec la fusion précédente ?

La branche fonctionnalité2 reste séparé de master ce qui n'était pas le cas pour fonctionnalité1

Comment utiliser Git Graph pour qu'il nous montre les différences entre l'ancienne version de fichier1.md et la version courante que l'on vient de committer ?

On clique sur le fichier en question dans git graph et on vois les modifications

Repartir sur master, et modifier fichier1.md en y ajoutant aussi une ligne (différente de celle qu'on a ajoutée sur l'autre branche) ; ajouter à l'index et commit

Tenter de fusionner la branche fonctionnalite3 avec master

git merge fonctionnalite3

Que se passe-t-il et pourquoi ?

Auto-merging fichier1.md.txt
CONFLICT (content): Merge conflict in fichier1.md.txt
Automatic merge failed; fix conflicts and then commit the result.

Il ne peux pas fusionner car il y'a plusieurs versions du fichier1.md donc ils entrent en conflit 

Que doit-on faire si on veut annuler la fusion en cours ? (ne pas lancer la commande)

il faut utiliser git merge --abort

Supprimer les trois branches fonctionnalitex (attention : on ne peut pas supprimer une branche sur laquelle on est)

git branch -d fonctionnalitex

Partie 4

Cloner localement votre fork (ne pas cloner le dépôt original)

git clone https://github.com/NolanMartinez/sio1-2024-java-grpb.git

Quelle est la différence entre un fork et un clonage ?

le clonage permet d'avoir les fichier localement sur son ordinateur tandit que le fork sur github

Indiquer dans quelles circonstances on voudrait forker et/ou cloner un dépôt

On prefera cloner si on veux modifier le depot localement meme sans accès a internet

On veut maintenant envoyer cette modification vers le dépôt distant

Il faut d'abord faire un add/commit local
Puis utiliser la commande qui « pousse » les modifs sur le dépôt GitHub (push)
Vérifier directement sur GitHub que le push a bien fonctionné

git add readme.md

git commit

git push

Trouver la commande qui affiche le nom du ou des dépôt(s) distant(s) relié(s) avec le dépôt local : cela permet de savoir si le dépôt courant est synchronisé avec un dépôt en ligne ou non

git remote -v

Créer une branche locale bugfix1, se déplacer dessus, créer un nouveau fichier ok.java à la racine du dépôt
Ajouter ok.java à l'index et faire un commit
Retourner sur master, créer le fichier ajout.java, ajouter à l'index et committer
Fusionner la branche bugfix1 dans la branche master
Afficher le log des commits ; noter les emplacements des trois branches différentes, en local et en remote
Head , master et bugfix1

 git branch bugfix1

nolan@Windows MINGW64 /c/clonegit/sio1-2024-java-grpb (master)
$ ls
README.md  pom.xml  src/

nolan@Windows MINGW64 /c/clonegit/sio1-2024-java-grpb (master)
$ git checkout bugfix1
Switched to branch 'bugfix1'

nolan@Windows MINGW64 /c/clonegit/sio1-2024-java-grpb (bugfix1)
$ git checkout master
Switched to branch 'master'
Your branch is up to date with 'origin/master'.

nolan@Windows MINGW64 /c/clonegit/sio1-2024-java-grpb (master)
$ touch ok.java

nolan@Windows MINGW64 /c/clonegit/sio1-2024-java-grpb (master)
$ git add ok.java

nolan@Windows MINGW64 /c/clonegit/sio1-2024-java-grpb (master)
$ git commit
[master 4d14242] sqdsd
 1 file changed, 0 insertions(+), 0 deletions(-)
 create mode 100644 ok.java

nolan@Windows MINGW64 /c/clonegit/sio1-2024-java-grpb (master)
$ rm ok.java

nolan@Windows MINGW64 /c/clonegit/sio1-2024-java-grpb (master)
$ git checkout bugfix1
Switched to branch 'bugfix1'

nolan@Windows MINGW64 /c/clonegit/sio1-2024-java-grpb (bugfix1)
$ touch ok.java

nolan@Windows MINGW64 /c/clonegit/sio1-2024-java-grpb (bugfix1)
$ git add ok.java

nolan@Windows MINGW64 /c/clonegit/sio1-2024-java-grpb (bugfix1)
$ git commit
[bugfix1 3098112] ok.java
 1 file changed, 0 insertions(+), 0 deletions(-)
 create mode 100644 ok.java

nolan@Windows MINGW64 /c/clonegit/sio1-2024-java-grpb (bugfix1)
$ git checkout master
Switched to branch 'master'
Your branch is ahead of 'origin/master' by 1 commit.
  (use "git push" to publish your local commits)

nolan@Windows MINGW64 /c/clonegit/sio1-2024-java-grpb (master)
$ touch ajout.java

nolan@Windows MINGW64 /c/clonegit/sio1-2024-java-grpb (master)
$ git add ajout.java

nolan@Windows MINGW64 /c/clonegit/sio1-2024-java-grpb (master)
$ git commit
[master a918cc0] ajout.java
 1 file changed, 0 insertions(+), 0 deletions(-)
 create mode 100644 ajout.java

nolan@Windows MINGW64 /c/clonegit/sio1-2024-java-grpb (master)
$ git merge bugfix1
Merge made by the 'ort' strategy.


Faire un push
Refaire un affichage du log ; origin/master a bougé : que représente cette branche ?
commit fb38626a394cf8ad9d18f266046c7d50828fbc71 (HEAD -> master, origin/master, origin/HEAD)
C'est la branche principale 

Étudier le résultat sur GitHub, en examinant commits et branches (bouton drop-down sur la page du dépôt pour voir les branches) : qu'est-ce qui est différent de la version locale ?
La branche bugfix1 n'existe plus sur github

Le bug est corrigé et intégré ; que doit-on faire de la branche bugfix1 maintenant ?
On peux la supprimer

Créer une nouvelle branche partage

git branch partage

Aller sur la branche

git checkout partage

Ajouter un fichier partage.md

touch partage.md

L'inclure dans l'index

git add partage.md

Faire un commit

git commit

Push

git push

Que se passe-t-il ?

il affiche un message d'erreur

Exécuter la bonne commande pour sauvegarder la branche sur le remote

git push --set-upstream origin partage

Vérifier sur GitHub que la branche apparaît bien

La branche partage n'a pas été fusionnée avant le push ; on va utiliser un autre moyen offert par GitHub pour fusionner une branche en remote : la Pull Request

La Pull Request est très utilisée en collaboration : elle permet à l'intégrateur du projet d'examiner les demandes de merge au niveau du remote avant de les accepter (ou non)
Sur GitHub, cliquer sur le bouton Compare & pull request, qui apparaît directement sur la page du dépôt depuis le dernier push qui a ajouté la branche (voir ci-dessus).

À gauche, la branche d'intégration (« base », qui reçoit le merge) ; à droite, la branche à fusionner (« compare »)

On doit fusionner partage dans master
Attention, il faut bien choisir le repo de base qui est sur votre propre compte (pas le compte du dépôt d'origine que vous avez forké)
On peut ajouter d'autres informations : titre et commentaire de la pull request, et même upload de fichiers annexes, liens éventuels... Également, on peut ajouter des labels pour étiquetter la pull request et lui affecter un reviewer, qui va officiellement être en charge
Valider en cliquant sur le bouton Create pull request
La page résultante informe sur les branches source et cible, sur les commits concernés, les fichiers qui ont été modifiés...

On peut aussi y démarrer une conversation notamment entre l'émetteur de la pull request et l'intégrateur

On voit que l'intégrateur (possesseur du compte cible) peut accepter la pull request en cliquant sur le bouton Merge pull request (ou refuser en cliquant sur Close pull request).

En discutant de la pull request, on se rend compte que certaines choses devraient être modifiées

Repartir en local pour effectuer une modification sur partage.md et ajouter precision.md
touch precision.md

git add precision.md

Commit des deux modifs

git commit

Push

git push

Finalement, faire le merge sur la page de la pull request
Noter que l'interface nous propose alors de supprimer la branche devenue inutile ; supprimer la branche

Dans un contexte de travail en collaboration sur un même dépôt, donner un workflow (façon de travailler) possible qui va permettre à tous les intervenants de viser des ajouts à la branche d'intégration, d'en discuter, et ceci sans danger pour la branche d'intégration, avant que finalement l'intégrateur (probablement propriétaire du dépot) accepte les changements.

On peux par exemple créer une branche pour tester des choses et ensuite seulement la mettre dans la branche d'intégration si elle est validé